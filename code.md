그런데 walk the stork는 왼쪽키를 누르면 왼쪽으로 향하고, 오른쪽을 누르면 오른쪽으로 향하는데 내가 고친 코드는 반대로 동작하거든.



이게 의도된걸까?

'Walk the Stork'와 같은 균형 잡기 게임에서 조작이 반대로 느껴지는 것은 **'직접 조작'**과 **'물리적 반응'**의 차이 때문입니다. 결론부터 말씀드리면, 현재 작성하신 코드는 머리의 각도를 직접 돌리는 방식이기 때문에 실제 물리 현상과는 반대로 동작하게 됩니다.

구체적으로 왜 그런지, 그리고 어떻게 수정해야 의도대로 동작할지 비교해 드릴게요.

1. 왜 반대로 동작하나요?
현재 코드의 로직 (직접 회전)
동작: ArrowLeft를 누르면 inputTorque가 음수(−)가 되어 머리를 왼쪽으로 직접 회전시킵니다.

결과: 왼쪽 키를 누르면 머리가 왼쪽으로 더 기울어지며 바닥으로 고꾸라집니다. 이는 유저가 "왼쪽으로 가려고 할 때" 오히려 더 빨리 넘어지는 결과를 초래합니다.

Walk the Stork의 로직 (관성 반응)
동작: 유저가 왼쪽 키를 누르면 캐릭터의 **발(Base)**이 왼쪽으로 이동합니다.

물리 현상 (관성): 바닥이 왼쪽으로 갑자기 움직이면, 위에 달린 머리는 관성에 의해 오른쪽으로 쏠리게 됩니다 (급정거하는 버스에서 몸이 앞으로 쏠리는 것과 같은 원리).

결과: 머리가 왼쪽으로 기울어지려 할 때 왼쪽 키를 눌러 발을 왼쪽으로 이동시키면, 관성에 의해 머리가 다시 오른쪽(중앙)으로 세워지며 균형이 잡힙니다.

2. 해결 방법: 두 가지 선택지
의도하시는 게임 스타일에 따라 아래 두 가지 방법 중 하나로 수정할 수 있습니다.

방법 A: 관성 물리 적용 (Walk the Stork 방식 추천)
카트(발)를 실제로 움직이고, 머리는 그 가속도에 반응하게 만듭니다. 이 방식이 훨씬 자연스럽고 게임답습니다.

JavaScript
// update 함수 내 수정 예시
let inputAccel = 0;
if (keys.ArrowLeft) {
    inputAccel = -BALANCE_FORCE; // 발을 왼쪽으로 가속
} else if (keys.ArrowRight) {
    inputAccel = BALANCE_FORCE;  // 발을 오른쪽으로 가속
}

// 머리의 토크 계산: 발이 왼쪽(-)으로 가속하면 머리는 오른쪽(+)으로 힘을 받음
const inertiaTorque = -inputAccel * 0.1; // 반대 방향으로 힘 전달
angularVelocity += (gravityTorque + inertiaTorque + noise) * dt;
방법 B: 입력 방향 반전 (단순 수정)
물리 엔진을 새로 만들기 번거롭다면, 현재 코드에서 입력의 방향만 바꿔도 훨씬 직관적이 됩니다. "머리가 왼쪽으로 쓰러질 때 왼쪽 키를 눌러서 오른쪽으로 밀어낸다"는 개념입니다.

JavaScript
// script.js의 입력 로직 반전
if (keys.ArrowLeft) {
    inputTorque += appliedForce; // 왼쪽 키를 누르면 오른쪽(+)으로 힘을 줌
}
if (keys.ArrowRight) {
    inputTorque -= appliedForce; // 오른쪽 키를 누르면 왼쪽(-)으로 힘을 줌
}
3. 요약 및 비교
구분	현재 코드	'Walk the Stork' 방식
조작 대상	머리(Face)의 각도	발(Cart)의 위치
왼쪽 키 입력 시	머리가 왼쪽으로 회전	발이 왼쪽으로 이동 → 머리는 오른쪽으로 쏠림
난이도	매우 높음 (기울어지면 회복 불가)	적절함 (발을 움직여 중심을 잡음)
추천 드리는 방향: 단순히 각도를 반전시키는 것보다, 카트(cartX)가 실제로 좌우로 움직이게 하고 그 가속도를 머리에 전달하는 방법 A를 적용해 보세요. 그래야 'Walk the Stork' 특유의 "허둥지둥 발을 맞춰가며 중심을 잡는" 재미가 살아납니다.